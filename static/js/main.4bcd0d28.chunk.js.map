{"version":3,"sources":["Class/Class.tsx","Store/GraphContext.tsx","Node.tsx","GraphController.tsx","App.js","serviceWorker.js","index.js"],"names":["NodeObject","cout","coord","heuristique","isWall","parent","this","Coord","x","y","Block","contextInit","graph","setGraph","e","start","setStart","finish","setFinish","reset","block","setBlock","GraphContext","createContext","GraphProvider","children","initGraph","widthMax","window","innerWidth","heightMax","innerHeight","graphTmp","xMax","line","yMax","nodeObject","push","useState","contextValue","Provider","value","Node","forwardRef","props","ref","useContext","color","colorBg","setColorBg","setIsWall","setCout","setWall","useImperativeHandle","setColor","console","log","resetColor","onMouseOver","preventDefault","buttons","onMouseEnterDo","onMouseDown","setStartfinish","style","border","width","height","backgroundColor","GraphController","useRef","refs","isOver","setIsOver","useEffect","current","compared2Nodes","node1","node2","sleep","ms","Promise","resolve","setTimeout","showPath","tab","a","aStarWiki","closedList","openList","startRef","finishRef","shift","curr","ret","reverse","calculatePath","neighboor","getNeighboorRef","forEach","v","includes","existWithLowerCost","d1","Math","abs","d2","floor","distanceBetweenNode","sort","length","setBlockType","type","disabled","onClick","className","borderSpacing","map","rows","index","lineRef","row","Component","el","key","App","Boolean","location","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","message"],"mappings":"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","file":"static/js/main.4bcd0d28.chunk.js","sourcesContent":["import React, { ForwardRefExoticComponent, RefAttributes, MutableRefObject} from 'react';\nimport Node from '../Node';\n\n\n\nexport type Props = {\n    x: number,\n    y: number,\n    color: string\n}\n/**\n * Layout to initialize the context\n */\nexport interface ContextLayout {\n    graph : [NodeObject[]?],\n    setGraph: (e: []) => void,\n    start: Coord,\n    setStart: (e: Coord) => void,\n    finish: Coord,\n    setFinish: (e: Coord) => void,\n    reset: () => void,\n    block: string,\n    setBlock: (e: string) => void\n}\n\n/**\n * Class: represent a box with it's property\n */\nexport class NodeObject {\n    public parent?: NodeObject;\n    public cout?: number;\n    public coord?: Coord;\n    public heuristique?: number;\n    public isWall?: boolean;\n\n\n    constructor(cout?: number, coord?: Coord, heuristique?: number, isWall?: boolean, parent?: NodeObject)\n    {\n        this.parent = parent;\n        this.cout = cout;\n        this.coord = coord;\n        this.heuristique = heuristique;\n        this.isWall = isWall;\n    }\n}\n\n/**\n * class: contains coordonate of a box\n */\nexport class Coord {\n    public x: number;\n    public y: number;\n    \n    constructor(x: number, y: number) \n    {\n        this.x = x;\n        this.y = y;\n    }\n}\n\nexport const Block = {\n    START:  \"start\" , \n    FINISH: \"finish\",\n    WALL:    \"wall\"\n}","import React, { createContext, useState, useRef, FunctionComponent, MutableRefObject } from 'react';\nimport { NodeObject, Coord, ContextLayout} from '../Class/Class'\n\nconst contextInit : ContextLayout = {\n    graph : [[]],\n    setGraph: (e: []) => {},\n    start: new Coord(-1,-1),\n    setStart: (e: Coord) => {},\n    finish: new Coord(0,0),\n    setFinish: (e: Coord) => {},\n    reset: () => {},\n    block: \"\",\n    setBlock: (e: string) => {}\n};\n\nexport const GraphContext = createContext(\n    contextInit\n);\n\ntype GraphProviderProps = {}\n\nconst GraphProvider: FunctionComponent<GraphProviderProps> = ({children}) => {\n\n    const initGraph = () => {\n        let widthMax : number = window.innerWidth / 30\n        let heightMax : number = window.innerHeight / 40\n        let graphTmp : [NodeObject[]?] = [];\n        for (let xMax = 0; xMax < heightMax; xMax++ ) {\n            let line : NodeObject[] = []\n            for (let yMax = 0; yMax < widthMax; yMax++ ) {\n                const nodeObject = new NodeObject(0, new Coord(xMax, yMax), 0, false);\n                line.push(nodeObject)\n            }\n            graphTmp.push(line);\n        }\n        return graphTmp;\n\n    }\n\n    const [graph, setGraph] = useState(initGraph);\n    const [start, setStart] = useState(new Coord(-1,-1));\n    const [finish, setFinish] = useState(new Coord(-1,-1));\n    const [block, setBlock] = useState(\"\");\n\n    // TODO: refs type\n    const reset = () => {\n        \n        setGraph(initGraph);\n        setStart(new Coord(-1,-1));\n        setFinish(new Coord(-1,-1));\n    }\n\n    const contextValue : ContextLayout = {\n        graph: graph,\n        setGraph: (e : []) => setGraph(e),\n        start: start,\n        setStart: (e : Coord) => setStart(e),\n        finish: finish,\n        setFinish: (e : Coord) => setFinish(e),\n        reset: () => reset(),\n        block: block,\n        setBlock: (e : string) => setBlock(e)\n    };\n\n    return (\n        <div>\n            <GraphContext.Provider value={contextValue}>\n                {children}\n            </GraphContext.Provider>\n        </div>\n    );\n}\n\nexport default GraphProvider;","import React, { useState, useContext, useEffect, forwardRef, useImperativeHandle,  } from 'react';\nimport { GraphContext } from './Store/GraphContext';\nimport { Block, Coord, Props } from './Class/Class';\n\nexport type NodeHandle = {\n\n    coord: Coord,\n\n    colorBg: string,\n\n    setColor: (color: string) => void,\n    \n    resetColor: () => void,\n\n    setIsWall: (isWall: boolean) =>void,\n\n    setCout: (cout: number) => void\n}\n\nconst Node = forwardRef<NodeHandle, Props>((props: Props, ref) => {\n    const {graph, start, setStart, finish, setFinish, block} = useContext(GraphContext);\n    const [coord, setCoord] = useState(new Coord(props.x, props.y));\n    const [colorBg, setColorBg] = useState(props.color);\n    const [isWall, setIsWall] = useState(false);\n    const [cout, setCout] = useState(0);\n    const [heuristique, setHeuristique] = useState(0)\n\n    const {x, y} = coord;\n\n    /*useEffect(() => {\n        if (refs.current === [])\n            setColor(\"white\")\n    }, [refs])*/\n\n    function setWall() {\n        if (block === Block.WALL) \n        {\n            setIsWall(true)\n            const graphObj = graph[coord.x]![coord.y]\n            \n            graphObj!.isWall = true\n            setColorBg(\"black\");\n        }\n    }\n\n    const setStartfinish = (e: React.MouseEvent) => {\n        e.preventDefault();\n        console.log(\"clic\", coord)\n        if (block === Block.START && start.x === -1)\n        {\n            setStart(new Coord(x, y));\n            setColorBg(\"blue\")\n            console.log(\"set start\");\n        }\n        else if (block === Block.FINISH && finish.x === -1)\n        {\n            setFinish(new Coord(x, y));\n            setColorBg(\"yellow\");\n            console.log(\"set finish\");\n        }\n        else {\n            setWall()\n        } \n    }\n\n    function onMouseEnterDo(e : React.MouseEvent){\n        e.preventDefault();\n        if(e.buttons===1){//code for left click}\n            setWall()\n        }\n    }\n\n    useImperativeHandle(ref, () => ({\n\n        coord: coord, \n\n        colorBg: colorBg,\n\n        setColor: (color: string) => {\n            console.log(colorBg)\n            if (colorBg !== \"blue\" && colorBg !== \"yellow\")\n                setColorBg(color)\n        },\n        \n        resetColor: () => {\n            setColorBg(\"white\");\n        },\n\n        setIsWall: (isWall: boolean) => {\n            setIsWall(isWall);\n        },\n\n        setCout: (cout: number) => {\n            setCout(cout);\n        }\n    \n    }));\n\n    return (\n        <td onMouseOver={(e) => onMouseEnterDo(e)} onMouseDown={(e) => setStartfinish(e)} style={{ border: \"1px solid #333\", width: \"30px\", height: \"30px\", backgroundColor: colorBg}}>\n            {isWall ? \"\" : \"\"}\n        </td>\n    );\n})\n\nexport default Node;","import React, { useContext, useState, useRef, useEffect } from 'react';\nimport { GraphContext } from './Store/GraphContext';\nimport { Block, NodeObject } from './Class/Class';\nimport  Node  from './Node';\n\nconst GraphController = () => {\n    const {graph, start, finish, reset, block, setBlock} = useContext(GraphContext);\n\n    type NodeHandle = React.ElementRef<typeof Node>;\n    const [refs, setRefs] = useState(useRef<[NodeHandle[]?]>([]));\n\n\n    const [isOver, setIsOver] = useState(true)\n    \n    useEffect(() => {\n        console.log(\"changed graph\", graph);\n        console.log(\"reset\")\n        for (const line of refs!.current!) {\n            for(const ref of line!) {\n                if (ref) {\n                    ref.resetColor()\n                    ref.setCout(0)\n                    ref.setIsWall(false)\n                }\n            }\n        }\n    }, [graph]);\n\n    const compared2Nodes = (node1: NodeObject, node2: NodeObject) =>{\n        if (node1!.heuristique! < node2!.heuristique! ) {\n            return -1;\n        }\n        else if (node1!.heuristique! === node2!.heuristique!) {\n            return 0;\n        }\n        else return 1;\n    }\n\n    const distanceBetweenNode = (node1: NodeObject, node2: NodeObject) => {\n        const d1 = Math.abs((node1.coord!.x) - (node2.coord!.x));\n        const d2 = Math.abs((node1.coord!.x) - (node2.coord!.y));\n        return Math.floor(d1 + d2);\n    }\n\n    // refactor\n    const getNeighboorRef = (x: number, y: number) => {\n        let neighboor = [];\n        //top\n        if ((graph[x-1] && graph[x-1]![y])) {\n            neighboor.push(graph[x-1]![y]);\n        }\n        //bottom\n        if ((graph[x+1] && graph[x+1]![y])) {\n            neighboor.push(graph[x+1]![y]);\n        }\n        //left\n        if ((graph[x] && graph[x]![y-1])) {\n            neighboor.push(graph[x]![y-1]);\n        }\n        //right\n        if ((graph[x] && graph[x]![y+1])) {\n            neighboor.push(graph[x]![y+1]);\n        }\n        return neighboor;\n    }\n\n    // TODO : replace for by find\n    const existWithLowerCost = (v: NodeObject, tab: NodeObject[]) => {\n        if (tab.includes(v)) {\n            for (const value of tab) {\n                if (value.cout! <= v.cout!)\n                    return true;\n                return false;\n            }\n        }\n        return false;\n    }\n\n    const sleep = (ms: number) => {\n        return new Promise(resolve => setTimeout(resolve, ms))\n    }\n\n    const showPath = async (tab: NodeObject[]) => {\n        console.log(tab)\n        for (const ref of tab) {\n            await sleep(200)\n            if (ref.coord!.x !== finish.x || ref.coord!.y !== finish.y)    \n                refs.current![ref.coord!.x]![ref.coord!.y].setColor(\"green\");\n        }\n        setIsOver(true)\n    }\n\n    const calculatePath = (current: NodeObject) => {\n        let curr = current;\n        let ret = []\n\n        while (curr.parent) {\n            ret.push(curr);\n            curr = curr.parent;\n        }\n\n        showPath(ret.reverse());\n    }\n\n\n    // TODO: The sort didn't work openlist is a priority queue ? \n    const aStarWiki = () => {\n        setIsOver(false)\n        let closedList : NodeObject[] = [];\n        let openList : NodeObject[] = [];\n        if (start.x === -1 && start.y === -1 || finish.x === -1 && finish.y === -1)\n            return;\n        const startRef = graph[start.x]![start.y];\n        const finishRef = graph[finish.x]![finish.y];\n        openList.push(startRef);\n        while (openList.length > 0) {\n            const current = openList.shift();\n            if (current!.coord!.x === finishRef!.coord!.x && current!.coord!.y === finishRef!.coord!.y) {\n                calculatePath(current!)\n                return;\n            }\n\n            getNeighboorRef(current!.coord!.x, current!.coord!.y).forEach((v) => {\n                if (closedList.includes(v) || existWithLowerCost(v, openList) || v.isWall) {\n                    return;\n                }    \n                else {\n                    v.cout = current!.cout! + 1;\n                    //if (current!.cout)\n                    //    refs.current[v.coord!.x][v.coord!.y].setCout(current!.cout + 1)\n                    v.heuristique = v.cout + distanceBetweenNode(v, finishRef);\n                    v.parent = current;\n                    openList.push(v);\n                    openList.sort(compared2Nodes)\n                }\n            });\n            closedList.push(current!);\n        }\n        return [];\n    }\n\n\n    const setBlockType = (type: string) => {\n        setBlock(type);\n    }\n\n    return (\n        <div>\n            <div>\n                <button disabled={!isOver} onClick={() => setBlockType(Block.START)}>Start</button>\n                <button disabled={!isOver} onClick={() => setBlockType(Block.FINISH)}>Finish</button>\n                <button disabled={!isOver} onClick={() => setBlockType(Block.WALL)}>Wall</button>\n            </div>\n            <div>\n            <table className=\"Graph\" style={{borderSpacing: 0}}>\n                \n                <tbody>\n                {\n                    \n                    graph.map((rows, index) => {\n                        let x = index\n                        let lineRef : NodeHandle[]= []\n                        let row = rows!.map((Component, index) => {\n                            return <Node color=\"white\" ref={(el: NodeHandle) => lineRef.push(el)} x={x} y={index} key={x + ':' + index} />\n                        })\n                        refs.current!.push(lineRef)\n                        return <tr className=\"row\" key={index}>{row}</tr>\n                    })\n                    \n                }\n                </tbody>\n            </table>\n            </div>\n            <button disabled={!isOver} onClick= {() => aStarWiki()}>Resolve</button>\n            <button disabled={!isOver} onClick={() => reset()}>Reset</button>\n        </div>\n    );\n}\n\nexport default GraphController;","import React from 'react';\nimport GraphProvider from './Store/GraphContext';\nimport GraphController from './GraphController';\nimport './App.css';\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <GraphProvider />\n      <GraphProvider>\n        <GraphController />\n      </GraphProvider>\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}